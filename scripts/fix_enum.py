import re
import glob

files = glob.glob(r'd:\DEVHUB\sortmail\backend\alembic\versions\*_tz_aware_datetimes.py')
if not files:
    print("No alembic migration file found.")
    exit(1)
file_path = sorted(files)[-1]  # get the most recent one

with open(file_path, 'r', encoding='utf-8') as f:
    content = f.read()

# 1. Split content to avoid touching downgrade()
upgrade_idx = content.find("def upgrade() -> None:")
downgrade_idx = content.find("def downgrade() -> None:")

if upgrade_idx != -1 and downgrade_idx != -1:
    header_content = content[:upgrade_idx]
    upgrade_content = content[upgrade_idx:downgrade_idx]
    downgrade_content = content[downgrade_idx:]
    
    # 2. Extract drop_index statements ONLY from upgrade()
    drop_indices = []
    
    def extract_drop_index(match):
        drop_indices.append(match.group(0))
        return ""
        
    upgrade_content = re.sub(r"^\s*op\.drop_index\(.*?$\n", extract_drop_index, upgrade_content, flags=re.MULTILINE)
    
    upgrade_marker = "def upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n"
    
    cleanups = [
        "    op.execute(\"DELETE FROM connected_accounts WHERE provider_user_id IS NULL OR provider_email IS NULL OR scopes IS NULL\")\n",
        "    op.execute(\"DELETE FROM attachments WHERE filename_sanitized IS NULL OR content_type IS NULL OR sha256_hash IS NULL\")\n",
        "    op.execute(\"UPDATE workspaces SET plan = 'TEAM' WHERE plan IS NULL\")\n",
        "    op.execute(\"UPDATE workspaces SET status = 'ACTIVE' WHERE status IS NULL\")\n",
        "    op.execute(\"DELETE FROM calendar_suggestions WHERE event_type IS NULL OR status IS NULL\")\n",
        "    op.execute(\"DELETE FROM drafts\")\n"
    ]

    if upgrade_marker in upgrade_content:
        upgrade_content = upgrade_content.replace(
            upgrade_marker, 
            upgrade_marker + "".join(cleanups) + "".join(drop_indices)
        )
        
    content = header_content + upgrade_content + downgrade_content

# 3. Modify op.drop_table to use CASCADE
content = re.sub(r"op\.drop_table\('([^']+)'\)", r"op.execute('DROP TABLE IF EXISTS \1 CASCADE')", content)

# 4. Patch Enum Alter Columns
blocks = content.split('op.alter_column(')
new_blocks = [blocks[0]]

for b in blocks[1:]:
    if 'type_=sa.Enum' in b or 'type_=postgresql.ENUM' in b:
        try:
            col_part = b.split(',')[1]
            table_match = re.search(r"'([^']+)'", b.split(',')[0])
            col_match = re.search(r"'([^']+)'", col_part)
            if table_match and col_match:
                table_name = table_match.group(1)
                col_name = col_match.group(1)
                
                type_idx = b.find("type_=")
                name_match = None
                if type_idx != -1:
                    name_match = re.search(r"name='([^']+)'", b[type_idx:])
                
                if name_match:
                    enum_name = name_match.group(1)
                
                if 'postgresql_using' not in b:
                    insertion = f"postgresql_using='\"{col_name}\"::text::{enum_name}', "
                    if 'nullable=' in b:
                        b = b.replace('nullable=', insertion + 'nullable=', 1)
                    elif 'existing_nullable=' in b:
                        b = b.replace('existing_nullable=', insertion + 'existing_nullable=', 1)
                
                b = re.sub(r",\s*existing_server_default=[^\)]+\)(?!\s*op\.)", "", b)

                new_blocks[-1] += f"op.execute(\"ALTER TABLE {table_name} ALTER COLUMN {col_name} DROP DEFAULT\")\n    "
        except Exception as e:
            pass
            
    new_blocks.append(b)

with open(file_path, 'w', encoding='utf-8') as f:
    f.write('op.alter_column('.join(new_blocks))

print("Fixed Postgres ENUM defaults, USING types, Index Drops, and Cascading Drops successfully.")
